const axios = require('axios');

/**
 * üåê CVE Details API Integration
 * Lookup CVE information for detected vulnerabilities
 * 
 * API Reference: https://cve.circl.lu/api/
 * - Free unlimited requests
 * - No API key required
 * - Comprehensive CVE database
 */
class CVELookup {
  constructor() {
    this.name = 'CVE Details Lookup';
    this.version = '1.0.0';
    this.baseURL = 'https://cve.circl.lu/api';
    this.timeout = 10000; // 10 seconds
    
    // Initialize axios instance with default config
    this.api = axios.create({
      baseURL: this.baseURL,
      timeout: this.timeout,
      headers: {
        'User-Agent': 'SentinelHub-PasteScanner/1.0.0',
        'Accept': 'application/json'
      }
    });

    console.log(`‚úÖ ${this.name} v${this.version} initialized`);
  }

  /**
   * Lookup CVEs by vulnerability keywords
   * @param {Array<string>} keywords - Vulnerability keywords to search
   * @returns {Array} CVE matches with details
   */
  async lookupByKeywords(keywords) {
    if (!keywords || keywords.length === 0) {
      return [];
    }

    console.log(`üåê Looking up CVEs for keywords: ${keywords.join(', ')}`);
    
    const cveResults = [];
    const uniqueCVEs = new Set();

    for (const keyword of keywords) {
      try {
        const results = await this.searchCVEByKeyword(keyword);
        
        // Filter and deduplicate results
        results.forEach(cve => {
          if (!uniqueCVEs.has(cve.id) && this.isRelevantCVE(cve, keyword)) {
            uniqueCVEs.add(cve.id);
            cveResults.push({
              ...cve,
              matchedKeyword: keyword,
              source: 'cve-circl'
            });
          }
        });
      } catch (error) {
        console.warn(`‚ö†Ô∏è Failed to lookup CVE for keyword "${keyword}":`, error.message);
      }
    }

    // Sort by CVSS score (highest first)
    cveResults.sort((a, b) => (b.cvss || 0) - (a.cvss || 0));

    console.log(`   ‚úì Found ${cveResults.length} relevant CVEs`);
    return cveResults.slice(0, 10); // Limit to top 10 results
  }

  /**
   * Search CVE database by keyword
   */
  async searchCVEByKeyword(keyword) {
    try {
      const response = await this.api.get(`/search/${encodeURIComponent(keyword)}`);
      
      if (response.data && Array.isArray(response.data)) {
        return response.data.map(cve => this.formatCVEData(cve));
      }
      
      return [];
    } catch (error) {
      if (error.response?.status === 404) {
        return []; // No results found
      }
      throw error;
    }
  }

  /**
   * Get detailed CVE information by CVE ID
   * @param {string} cveId - CVE identifier (e.g., CVE-2023-1234)
   * @returns {Object} Detailed CVE information
   */
  async getCVEDetails(cveId) {
    try {
      console.log(`üîç Fetching details for ${cveId}`);
      
      const response = await this.api.get(`/cve/${cveId}`);
      return this.formatCVEData(response.data);
    } catch (error) {
      console.warn(`‚ö†Ô∏è Failed to get CVE details for ${cveId}:`, error.message);
      return null;
    }
  }

  /**
   * Format CVE data into consistent structure
   */
  formatCVEData(rawCVE) {
    return {
      id: rawCVE.id || 'Unknown',
      summary: rawCVE.summary || 'No summary available',
      cvss: this.extractCVSS(rawCVE),
      cvssVector: rawCVE.cvss || null,
      severity: this.calculateSeverity(this.extractCVSS(rawCVE)),
      published: rawCVE.Published || rawCVE.published || null,
      modified: rawCVE.Modified || rawCVE.modified || null,
      references: this.extractReferences(rawCVE),
      cwe: this.extractCWE(rawCVE),
      vendors: this.extractVendors(rawCVE),
      products: this.extractProducts(rawCVE),
      impact: this.extractImpact(rawCVE),
      exploitabilityScore: rawCVE.exploitabilityScore || null,
      impactScore: rawCVE.impactScore || null
    };
  }

  /**
   * Extract CVSS score from CVE data
   */
  extractCVSS(cve) {
    // Try different possible CVSS fields
    if (cve.cvss3) return parseFloat(cve.cvss3);
    if (cve.cvss2) return parseFloat(cve.cvss2);
    if (cve.cvss) {
      const match = cve.cvss.match(/(\d+\.\d+)/);
      if (match) return parseFloat(match[1]);
    }
    if (cve.baseScore) return parseFloat(cve.baseScore);
    
    return null;
  }

  /**
   * Calculate severity level from CVSS score
   */
  calculateSeverity(cvss) {
    if (!cvss) return 'unknown';
    
    if (cvss >= 9.0) return 'critical';
    if (cvss >= 7.0) return 'high';
    if (cvss >= 4.0) return 'medium';
    return 'low';
  }

  /**
   * Extract references from CVE data
   */
  extractReferences(cve) {
    const references = [];
    
    if (cve.references) {
      cve.references.forEach(ref => {
        if (typeof ref === 'string') {
          references.push({ url: ref, type: 'reference' });
        } else if (ref.url) {
          references.push({
            url: ref.url,
            type: ref.type || 'reference',
            name: ref.name || null
          });
        }
      });
    }

    if (cve.References) {
      cve.References.forEach(ref => {
        references.push({
          url: ref,
          type: 'reference'
        });
      });
    }

    return references;
  }

  /**
   * Extract CWE information
   */
  extractCWE(cve) {
    if (cve.cwe) {
      if (Array.isArray(cve.cwe)) {
        return cve.cwe.map(c => ({
          id: c.id || c,
          name: c.name || null
        }));
      }
      return [{ id: cve.cwe, name: null }];
    }

    // Try to extract CWE from summary or description
    const text = (cve.summary || cve.description || '');
    const cweMatch = text.match(/CWE-(\d+)/gi);
    if (cweMatch) {
      return cweMatch.map(match => ({
        id: match.toUpperCase(),
        name: null
      }));
    }

    return [];
  }

  /**
   * Extract vendor information
   */
  extractVendors(cve) {
    if (cve.vendors) {
      return Object.keys(cve.vendors);
    }
    if (cve.vendor) {
      return Array.isArray(cve.vendor) ? cve.vendor : [cve.vendor];
    }
    return [];
  }

  /**
   * Extract product information
   */
  extractProducts(cve) {
    const products = [];
    
    if (cve.vendors) {
      Object.values(cve.vendors).forEach(vendorProducts => {
        if (Array.isArray(vendorProducts)) {
          products.push(...vendorProducts);
        } else if (typeof vendorProducts === 'object') {
          products.push(...Object.keys(vendorProducts));
        }
      });
    }

    if (cve.products && Array.isArray(cve.products)) {
      products.push(...cve.products);
    }

    return [...new Set(products)]; // Remove duplicates
  }

  /**
   * Extract impact information
   */
  extractImpact(cve) {
    const impact = {
      confidentiality: null,
      integrity: null,
      availability: null
    };

    if (cve.impact) {
      impact.confidentiality = cve.impact.confidentiality || null;
      impact.integrity = cve.impact.integrity || null;
      impact.availability = cve.impact.availability || null;
    }

    return impact;
  }

  /**
   * Check if CVE is relevant to the keyword
   */
  isRelevantCVE(cve, keyword) {
    const searchText = (
      (cve.summary || '') + 
      (cve.description || '') + 
      (cve.vendors || []).join(' ') + 
      (cve.products || []).join(' ')
    ).toLowerCase();

    const keywordLower = keyword.toLowerCase();
    
    // Check for direct keyword match
    if (searchText.includes(keywordLower)) {
      return true;
    }

    // Check for related terms
    const relatedTerms = this.getRelatedTerms(keywordLower);
    return relatedTerms.some(term => searchText.includes(term));
  }

  /**
   * Get related terms for better matching
   */
  getRelatedTerms(keyword) {
    const termMap = {
      'sql injection': ['sqli', 'sql inject', 'database injection'],
      'xss': ['cross-site scripting', 'cross site scripting', 'reflected xss', 'stored xss'],
      'csrf': ['cross-site request forgery', 'cross site request forgery'],
      'code injection': ['remote code execution', 'rce', 'command injection'],
      'path traversal': ['directory traversal', 'file inclusion', 'lfi', 'rfi'],
      'buffer overflow': ['buffer overrun', 'stack overflow', 'heap overflow'],
      'authentication': ['auth bypass', 'authentication bypass', 'login bypass']
    };

    return termMap[keyword] || [];
  }

  /**
   * Get trending CVEs (most recent high-severity)
   */
  async getTrendingCVEs(limit = 5) {
    try {
      console.log('üî• Fetching trending CVEs...');
      
      const response = await this.api.get('/last');
      
      if (response.data && Array.isArray(response.data)) {
        return response.data
          .map(cve => this.formatCVEData(cve))
          .filter(cve => cve.cvss >= 7.0) // High severity or above
          .slice(0, limit);
      }
      
      return [];
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to fetch trending CVEs:', error.message);
      return [];
    }
  }

  /**
   * Health check for the CVE service
   */
  async getHealth() {
    try {
      // Test with a simple query
      await this.api.get('/cve/CVE-2021-44228', { timeout: 5000 }); // Log4j vulnerability
      
      return {
        status: 'healthy',
        name: this.name,
        version: this.version,
        apiUrl: this.baseURL,
        capabilities: [
          'CVE Search by Keywords',
          'Detailed CVE Information',
          'CVSS Score Analysis',
          'Reference Links',
          'CWE Mapping',
          'Trending CVE Detection'
        ]
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message,
        name: this.name
      };
    }
  }

  /**
   * Get vulnerability statistics
   */
  async getVulnerabilityStats() {
    try {
      const stats = {
        totalCritical: 0,
        totalHigh: 0,
        totalMedium: 0,
        totalLow: 0,
        recentCVEs: []
      };

      // Get recent CVEs for statistics
      const recentCVEs = await this.getTrendingCVEs(20);
      stats.recentCVEs = recentCVEs.slice(0, 5);

      // Count by severity
      recentCVEs.forEach(cve => {
        switch (cve.severity) {
          case 'critical': stats.totalCritical++; break;
          case 'high': stats.totalHigh++; break;
          case 'medium': stats.totalMedium++; break;
          case 'low': stats.totalLow++; break;
        }
      });

      return stats;
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to get vulnerability stats:', error.message);
      return null;
    }
  }
}

module.exports = CVELookup;